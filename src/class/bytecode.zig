const std = @import("std");

pub const Opcode = enum(u8) {
    // Constants (0x00-0x14)
    nop = 0x00,
    aconst_null = 0x01,
    iconst_m1 = 0x02,
    iconst_0 = 0x03,
    iconst_1 = 0x04,
    iconst_2 = 0x05,
    iconst_3 = 0x06,
    iconst_4 = 0x07,
    iconst_5 = 0x08,
    lconst_0 = 0x09,
    lconst_1 = 0x0A,
    fconst_0 = 0x0B,
    fconst_1 = 0x0C,
    fconst_2 = 0x0D,
    dconst_0 = 0x0E,
    dconst_1 = 0x0F,
    bipush = 0x10,
    sipush = 0x11,
    ldc = 0x12,
    ldc_w = 0x13,
    ldc2_w = 0x14,

    // Loads (0x15-0x35)
    iload = 0x15,
    lload = 0x16,
    fload = 0x17,
    dload = 0x18,
    aload = 0x19,
    iload_0 = 0x1A,
    iload_1 = 0x1B,
    iload_2 = 0x1C,
    iload_3 = 0x1D,
    lload_0 = 0x1E,
    lload_1 = 0x1F,
    lload_2 = 0x20,
    lload_3 = 0x21,
    fload_0 = 0x22,
    fload_1 = 0x23,
    fload_2 = 0x24,
    fload_3 = 0x25,
    dload_0 = 0x26,
    dload_1 = 0x27,
    dload_2 = 0x28,
    dload_3 = 0x29,
    aload_0 = 0x2A,
    aload_1 = 0x2B,
    aload_2 = 0x2C,
    aload_3 = 0x2D,
    iaload = 0x2E,
    laload = 0x2F,
    faload = 0x30,
    daload = 0x31,
    aaload = 0x32,
    baload = 0x33,
    caload = 0x34,
    saload = 0x35,

    // Stores (0x36-0x56)
    istore = 0x36,
    lstore = 0x37,
    fstore = 0x38,
    dstore = 0x39,
    astore = 0x3A,
    istore_0 = 0x3B,
    istore_1 = 0x3C,
    istore_2 = 0x3D,
    istore_3 = 0x3E,
    lstore_0 = 0x3F,
    lstore_1 = 0x40,
    lstore_2 = 0x41,
    lstore_3 = 0x42,
    fstore_0 = 0x43,
    fstore_1 = 0x44,
    fstore_2 = 0x45,
    fstore_3 = 0x46,
    dstore_0 = 0x47,
    dstore_1 = 0x48,
    dstore_2 = 0x49,
    dstore_3 = 0x4A,
    astore_0 = 0x4B,
    astore_1 = 0x4C,
    astore_2 = 0x4D,
    astore_3 = 0x4E,
    iastore = 0x4F,
    lastore = 0x50,
    fastore = 0x51,
    dastore = 0x52,
    aastore = 0x53,
    bastore = 0x54,
    castore = 0x55,
    sastore = 0x56,

    // Stack operations (0x57-0x5F)
    pop = 0x57,
    pop2 = 0x58,
    dup = 0x59,
    dup_x1 = 0x5A,
    dup_x2 = 0x5B,
    dup2 = 0x5C,
    dup2_x1 = 0x5D,
    dup2_x2 = 0x5E,
    swap = 0x5F,

    // Math operations (0x60-0x83)
    iadd = 0x60,
    ladd = 0x61,
    fadd = 0x62,
    dadd = 0x63,
    isub = 0x64,
    lsub = 0x65,
    fsub = 0x66,
    dsub = 0x67,
    imul = 0x68,
    lmul = 0x69,
    fmul = 0x6A,
    dmul = 0x6B,
    idiv = 0x6C,
    ldiv = 0x6D,
    fdiv = 0x6E,
    ddiv = 0x6F,
    irem = 0x70,
    lrem = 0x71,
    frem = 0x72,
    drem = 0x73,
    ineg = 0x74,
    lneg = 0x75,
    fneg = 0x76,
    dneg = 0x77,
    ishl = 0x78,
    lshl = 0x79,
    ishr = 0x7A,
    lshr = 0x7B,
    iushr = 0x7C,
    lushr = 0x7D,
    iand = 0x7E,
    land = 0x7F,
    ior = 0x80,
    lor = 0x81,
    ixor = 0x82,
    lxor = 0x83,

    // Conversions (0x84-0x93)
    iinc = 0x84,
    i2l = 0x85,
    i2f = 0x86,
    i2d = 0x87,
    l2i = 0x88,
    l2f = 0x89,
    l2d = 0x8A,
    f2i = 0x8B,
    f2l = 0x8C,
    f2d = 0x8D,
    d2i = 0x8E,
    d2l = 0x8F,
    d2f = 0x90,
    i2b = 0x91,
    i2c = 0x92,
    i2s = 0x93,

    // Comparisons (0x94-0xA6)
    lcmp = 0x94,
    fcmpl = 0x95,
    fcmpg = 0x96,
    dcmpl = 0x97,
    dcmpg = 0x98,
    ifeq = 0x99,
    ifne = 0x9A,
    iflt = 0x9B,
    ifge = 0x9C,
    ifgt = 0x9D,
    ifle = 0x9E,
    if_icmpeq = 0x9F,
    if_icmpne = 0xA0,
    if_icmplt = 0xA1,
    if_icmpge = 0xA2,
    if_icmpgt = 0xA3,
    if_icmple = 0xA4,
    if_acmpeq = 0xA5,
    if_acmpne = 0xA6,

    // Control flow (0xA7-0xB1)
    goto = 0xA7,
    jsr = 0xA8,
    ret = 0xA9,
    tableswitch = 0xAA,
    lookupswitch = 0xAB,
    ireturn = 0xAC,
    lreturn = 0xAD,
    freturn = 0xAE,
    dreturn = 0xAF,
    areturn = 0xB0,
    @"return" = 0xB1,

    // References (0xB2-0xC3)
    getstatic = 0xB2,
    putstatic = 0xB3,
    getfield = 0xB4,
    putfield = 0xB5,
    invokevirtual = 0xB6,
    invokespecial = 0xB7,
    invokestatic = 0xB8,
    invokeinterface = 0xB9,
    invokedynamic = 0xBA,
    new = 0xBB,
    newarray = 0xBC,
    anewarray = 0xBD,
    arraylength = 0xBE,
    athrow = 0xBF,
    checkcast = 0xC0,
    instanceof = 0xC1,
    monitorenter = 0xC2,
    monitorexit = 0xC3,

    // Extended (0xC4-0xC9)
    wide = 0xC4,
    multianewarray = 0xC5,
    ifnull = 0xC6,
    ifnonnull = 0xC7,
    goto_w = 0xC8,
    jsr_w = 0xC9,

    // Reserved
    breakpoint = 0xCA,
    impdep1 = 0xFE,
    impdep2 = 0xFF,

    _,
};

pub const NewArrayType = enum(u8) {
    boolean = 4,
    char = 5,
    float = 6,
    double = 7,
    byte = 8,
    short = 9,
    int = 10,
    long = 11,
};

pub const InstructionInfo = struct {
    name: []const u8,
    operand_count: u8,
    description: []const u8,
};

pub fn getInstructionInfo(opcode: Opcode) InstructionInfo {
    return switch (opcode) {
        .nop => .{ .name = "nop", .operand_count = 0, .description = "Do nothing" },
        .aconst_null => .{ .name = "aconst_null", .operand_count = 0, .description = "Push null reference" },
        .iconst_m1 => .{ .name = "iconst_m1", .operand_count = 0, .description = "Push int -1" },
        .iconst_0 => .{ .name = "iconst_0", .operand_count = 0, .description = "Push int 0" },
        .iconst_1 => .{ .name = "iconst_1", .operand_count = 0, .description = "Push int 1" },
        .iconst_2 => .{ .name = "iconst_2", .operand_count = 0, .description = "Push int 2" },
        .iconst_3 => .{ .name = "iconst_3", .operand_count = 0, .description = "Push int 3" },
        .iconst_4 => .{ .name = "iconst_4", .operand_count = 0, .description = "Push int 4" },
        .iconst_5 => .{ .name = "iconst_5", .operand_count = 0, .description = "Push int 5" },
        .lconst_0 => .{ .name = "lconst_0", .operand_count = 0, .description = "Push long 0" },
        .lconst_1 => .{ .name = "lconst_1", .operand_count = 0, .description = "Push long 1" },
        .fconst_0 => .{ .name = "fconst_0", .operand_count = 0, .description = "Push float 0.0" },
        .fconst_1 => .{ .name = "fconst_1", .operand_count = 0, .description = "Push float 1.0" },
        .fconst_2 => .{ .name = "fconst_2", .operand_count = 0, .description = "Push float 2.0" },
        .dconst_0 => .{ .name = "dconst_0", .operand_count = 0, .description = "Push double 0.0" },
        .dconst_1 => .{ .name = "dconst_1", .operand_count = 0, .description = "Push double 1.0" },
        .bipush => .{ .name = "bipush", .operand_count = 1, .description = "Push byte as int" },
        .sipush => .{ .name = "sipush", .operand_count = 2, .description = "Push short as int" },
        .ldc => .{ .name = "ldc", .operand_count = 1, .description = "Push item from constant pool" },
        .ldc_w => .{ .name = "ldc_w", .operand_count = 2, .description = "Push item from constant pool (wide)" },
        .ldc2_w => .{ .name = "ldc2_w", .operand_count = 2, .description = "Push long/double from constant pool" },
        .iload => .{ .name = "iload", .operand_count = 1, .description = "Load int from local variable" },
        .lload => .{ .name = "lload", .operand_count = 1, .description = "Load long from local variable" },
        .fload => .{ .name = "fload", .operand_count = 1, .description = "Load float from local variable" },
        .dload => .{ .name = "dload", .operand_count = 1, .description = "Load double from local variable" },
        .aload => .{ .name = "aload", .operand_count = 1, .description = "Load reference from local variable" },
        .iload_0 => .{ .name = "iload_0", .operand_count = 0, .description = "Load int from local variable 0" },
        .iload_1 => .{ .name = "iload_1", .operand_count = 0, .description = "Load int from local variable 1" },
        .iload_2 => .{ .name = "iload_2", .operand_count = 0, .description = "Load int from local variable 2" },
        .iload_3 => .{ .name = "iload_3", .operand_count = 0, .description = "Load int from local variable 3" },
        .lload_0 => .{ .name = "lload_0", .operand_count = 0, .description = "Load long from local variable 0" },
        .lload_1 => .{ .name = "lload_1", .operand_count = 0, .description = "Load long from local variable 1" },
        .lload_2 => .{ .name = "lload_2", .operand_count = 0, .description = "Load long from local variable 2" },
        .lload_3 => .{ .name = "lload_3", .operand_count = 0, .description = "Load long from local variable 3" },
        .fload_0 => .{ .name = "fload_0", .operand_count = 0, .description = "Load float from local variable 0" },
        .fload_1 => .{ .name = "fload_1", .operand_count = 0, .description = "Load float from local variable 1" },
        .fload_2 => .{ .name = "fload_2", .operand_count = 0, .description = "Load float from local variable 2" },
        .fload_3 => .{ .name = "fload_3", .operand_count = 0, .description = "Load float from local variable 3" },
        .dload_0 => .{ .name = "dload_0", .operand_count = 0, .description = "Load double from local variable 0" },
        .dload_1 => .{ .name = "dload_1", .operand_count = 0, .description = "Load double from local variable 1" },
        .dload_2 => .{ .name = "dload_2", .operand_count = 0, .description = "Load double from local variable 2" },
        .dload_3 => .{ .name = "dload_3", .operand_count = 0, .description = "Load double from local variable 3" },
        .aload_0 => .{ .name = "aload_0", .operand_count = 0, .description = "Load reference from local variable 0" },
        .aload_1 => .{ .name = "aload_1", .operand_count = 0, .description = "Load reference from local variable 1" },
        .aload_2 => .{ .name = "aload_2", .operand_count = 0, .description = "Load reference from local variable 2" },
        .aload_3 => .{ .name = "aload_3", .operand_count = 0, .description = "Load reference from local variable 3" },
        .iaload => .{ .name = "iaload", .operand_count = 0, .description = "Load int from array" },
        .laload => .{ .name = "laload", .operand_count = 0, .description = "Load long from array" },
        .faload => .{ .name = "faload", .operand_count = 0, .description = "Load float from array" },
        .daload => .{ .name = "daload", .operand_count = 0, .description = "Load double from array" },
        .aaload => .{ .name = "aaload", .operand_count = 0, .description = "Load reference from array" },
        .baload => .{ .name = "baload", .operand_count = 0, .description = "Load byte from array" },
        .caload => .{ .name = "caload", .operand_count = 0, .description = "Load char from array" },
        .saload => .{ .name = "saload", .operand_count = 0, .description = "Load short from array" },
        .istore => .{ .name = "istore", .operand_count = 1, .description = "Store int to local variable" },
        .lstore => .{ .name = "lstore", .operand_count = 1, .description = "Store long to local variable" },
        .fstore => .{ .name = "fstore", .operand_count = 1, .description = "Store float to local variable" },
        .dstore => .{ .name = "dstore", .operand_count = 1, .description = "Store double to local variable" },
        .astore => .{ .name = "astore", .operand_count = 1, .description = "Store reference to local variable" },
        .istore_0 => .{ .name = "istore_0", .operand_count = 0, .description = "Store int to local variable 0" },
        .istore_1 => .{ .name = "istore_1", .operand_count = 0, .description = "Store int to local variable 1" },
        .istore_2 => .{ .name = "istore_2", .operand_count = 0, .description = "Store int to local variable 2" },
        .istore_3 => .{ .name = "istore_3", .operand_count = 0, .description = "Store int to local variable 3" },
        .lstore_0 => .{ .name = "lstore_0", .operand_count = 0, .description = "Store long to local variable 0" },
        .lstore_1 => .{ .name = "lstore_1", .operand_count = 0, .description = "Store long to local variable 1" },
        .lstore_2 => .{ .name = "lstore_2", .operand_count = 0, .description = "Store long to local variable 2" },
        .lstore_3 => .{ .name = "lstore_3", .operand_count = 0, .description = "Store long to local variable 3" },
        .fstore_0 => .{ .name = "fstore_0", .operand_count = 0, .description = "Store float to local variable 0" },
        .fstore_1 => .{ .name = "fstore_1", .operand_count = 0, .description = "Store float to local variable 1" },
        .fstore_2 => .{ .name = "fstore_2", .operand_count = 0, .description = "Store float to local variable 2" },
        .fstore_3 => .{ .name = "fstore_3", .operand_count = 0, .description = "Store float to local variable 3" },
        .dstore_0 => .{ .name = "dstore_0", .operand_count = 0, .description = "Store double to local variable 0" },
        .dstore_1 => .{ .name = "dstore_1", .operand_count = 0, .description = "Store double to local variable 1" },
        .dstore_2 => .{ .name = "dstore_2", .operand_count = 0, .description = "Store double to local variable 2" },
        .dstore_3 => .{ .name = "dstore_3", .operand_count = 0, .description = "Store double to local variable 3" },
        .astore_0 => .{ .name = "astore_0", .operand_count = 0, .description = "Store reference to local variable 0" },
        .astore_1 => .{ .name = "astore_1", .operand_count = 0, .description = "Store reference to local variable 1" },
        .astore_2 => .{ .name = "astore_2", .operand_count = 0, .description = "Store reference to local variable 2" },
        .astore_3 => .{ .name = "astore_3", .operand_count = 0, .description = "Store reference to local variable 3" },
        .iastore => .{ .name = "iastore", .operand_count = 0, .description = "Store int to array" },
        .lastore => .{ .name = "lastore", .operand_count = 0, .description = "Store long to array" },
        .fastore => .{ .name = "fastore", .operand_count = 0, .description = "Store float to array" },
        .dastore => .{ .name = "dastore", .operand_count = 0, .description = "Store double to array" },
        .aastore => .{ .name = "aastore", .operand_count = 0, .description = "Store reference to array" },
        .bastore => .{ .name = "bastore", .operand_count = 0, .description = "Store byte to array" },
        .castore => .{ .name = "castore", .operand_count = 0, .description = "Store char to array" },
        .sastore => .{ .name = "sastore", .operand_count = 0, .description = "Store short to array" },
        .pop => .{ .name = "pop", .operand_count = 0, .description = "Pop top stack value" },
        .pop2 => .{ .name = "pop2", .operand_count = 0, .description = "Pop top two stack values" },
        .dup => .{ .name = "dup", .operand_count = 0, .description = "Duplicate top stack value" },
        .dup_x1 => .{ .name = "dup_x1", .operand_count = 0, .description = "Duplicate top stack value and insert below second value" },
        .dup_x2 => .{ .name = "dup_x2", .operand_count = 0, .description = "Duplicate top stack value and insert below third value" },
        .dup2 => .{ .name = "dup2", .operand_count = 0, .description = "Duplicate top two stack values" },
        .dup2_x1 => .{ .name = "dup2_x1", .operand_count = 0, .description = "Duplicate top two stack values and insert below third value" },
        .dup2_x2 => .{ .name = "dup2_x2", .operand_count = 0, .description = "Duplicate top two stack values and insert below fourth value" },
        .swap => .{ .name = "swap", .operand_count = 0, .description = "Swap top two stack values" },
        .iadd => .{ .name = "iadd", .operand_count = 0, .description = "Add two ints" },
        .ladd => .{ .name = "ladd", .operand_count = 0, .description = "Add two longs" },
        .fadd => .{ .name = "fadd", .operand_count = 0, .description = "Add two floats" },
        .dadd => .{ .name = "dadd", .operand_count = 0, .description = "Add two doubles" },
        .isub => .{ .name = "isub", .operand_count = 0, .description = "Subtract int" },
        .lsub => .{ .name = "lsub", .operand_count = 0, .description = "Subtract long" },
        .fsub => .{ .name = "fsub", .operand_count = 0, .description = "Subtract float" },
        .dsub => .{ .name = "dsub", .operand_count = 0, .description = "Subtract double" },
        .imul => .{ .name = "imul", .operand_count = 0, .description = "Multiply int" },
        .lmul => .{ .name = "lmul", .operand_count = 0, .description = "Multiply long" },
        .fmul => .{ .name = "fmul", .operand_count = 0, .description = "Multiply float" },
        .dmul => .{ .name = "dmul", .operand_count = 0, .description = "Multiply double" },
        .idiv => .{ .name = "idiv", .operand_count = 0, .description = "Divide int" },
        .ldiv => .{ .name = "ldiv", .operand_count = 0, .description = "Divide long" },
        .fdiv => .{ .name = "fdiv", .operand_count = 0, .description = "Divide float" },
        .ddiv => .{ .name = "ddiv", .operand_count = 0, .description = "Divide double" },
        .irem => .{ .name = "irem", .operand_count = 0, .description = "Remainder int" },
        .lrem => .{ .name = "lrem", .operand_count = 0, .description = "Remainder long" },
        .frem => .{ .name = "frem", .operand_count = 0, .description = "Remainder float" },
        .drem => .{ .name = "drem", .operand_count = 0, .description = "Remainder double" },
        .ineg => .{ .name = "ineg", .operand_count = 0, .description = "Negate int" },
        .lneg => .{ .name = "lneg", .operand_count = 0, .description = "Negate long" },
        .fneg => .{ .name = "fneg", .operand_count = 0, .description = "Negate float" },
        .dneg => .{ .name = "dneg", .operand_count = 0, .description = "Negate double" },
        .ishl => .{ .name = "ishl", .operand_count = 0, .description = "Shift left int" },
        .lshl => .{ .name = "lshl", .operand_count = 0, .description = "Shift left long" },
        .ishr => .{ .name = "ishr", .operand_count = 0, .description = "Arithmetic shift right int" },
        .lshr => .{ .name = "lshr", .operand_count = 0, .description = "Arithmetic shift right long" },
        .iushr => .{ .name = "iushr", .operand_count = 0, .description = "Logical shift right int" },
        .lushr => .{ .name = "lushr", .operand_count = 0, .description = "Logical shift right long" },
        .iand => .{ .name = "iand", .operand_count = 0, .description = "Boolean AND int" },
        .land => .{ .name = "land", .operand_count = 0, .description = "Boolean AND long" },
        .ior => .{ .name = "ior", .operand_count = 0, .description = "Boolean OR int" },
        .lor => .{ .name = "lor", .operand_count = 0, .description = "Boolean OR long" },
        .ixor => .{ .name = "ixor", .operand_count = 0, .description = "Boolean XOR int" },
        .lxor => .{ .name = "lxor", .operand_count = 0, .description = "Boolean XOR long" },
        .iinc => .{ .name = "iinc", .operand_count = 2, .description = "Increment local variable" },
        .i2l => .{ .name = "i2l", .operand_count = 0, .description = "Convert int to long" },
        .i2f => .{ .name = "i2f", .operand_count = 0, .description = "Convert int to float" },
        .i2d => .{ .name = "i2d", .operand_count = 0, .description = "Convert int to double" },
        .l2i => .{ .name = "l2i", .operand_count = 0, .description = "Convert long to int" },
        .l2f => .{ .name = "l2f", .operand_count = 0, .description = "Convert long to float" },
        .l2d => .{ .name = "l2d", .operand_count = 0, .description = "Convert long to double" },
        .f2i => .{ .name = "f2i", .operand_count = 0, .description = "Convert float to int" },
        .f2l => .{ .name = "f2l", .operand_count = 0, .description = "Convert float to long" },
        .f2d => .{ .name = "f2d", .operand_count = 0, .description = "Convert float to double" },
        .d2i => .{ .name = "d2i", .operand_count = 0, .description = "Convert double to int" },
        .d2l => .{ .name = "d2l", .operand_count = 0, .description = "Convert double to long" },
        .d2f => .{ .name = "d2f", .operand_count = 0, .description = "Convert double to float" },
        .i2b => .{ .name = "i2b", .operand_count = 0, .description = "Convert int to byte" },
        .i2c => .{ .name = "i2c", .operand_count = 0, .description = "Convert int to char" },
        .i2s => .{ .name = "i2s", .operand_count = 0, .description = "Convert int to short" },
        .lcmp => .{ .name = "lcmp", .operand_count = 0, .description = "Compare longs" },
        .fcmpl => .{ .name = "fcmpl", .operand_count = 0, .description = "Compare floats (NaN is -1)" },
        .fcmpg => .{ .name = "fcmpg", .operand_count = 0, .description = "Compare floats (NaN is 1)" },
        .dcmpl => .{ .name = "dcmpl", .operand_count = 0, .description = "Compare doubles (NaN is -1)" },
        .dcmpg => .{ .name = "dcmpg", .operand_count = 0, .description = "Compare doubles (NaN is 1)" },
        .ifeq => .{ .name = "ifeq", .operand_count = 2, .description = "Branch if int equals zero" },
        .ifne => .{ .name = "ifne", .operand_count = 2, .description = "Branch if int not equals zero" },
        .iflt => .{ .name = "iflt", .operand_count = 2, .description = "Branch if int less than zero" },
        .ifge => .{ .name = "ifge", .operand_count = 2, .description = "Branch if int greater than or equal zero" },
        .ifgt => .{ .name = "ifgt", .operand_count = 2, .description = "Branch if int greater than zero" },
        .ifle => .{ .name = "ifle", .operand_count = 2, .description = "Branch if int less than or equal zero" },
        .if_icmpeq => .{ .name = "if_icmpeq", .operand_count = 2, .description = "Branch if ints equal" },
        .if_icmpne => .{ .name = "if_icmpne", .operand_count = 2, .description = "Branch if ints not equal" },
        .if_icmplt => .{ .name = "if_icmplt", .operand_count = 2, .description = "Branch if int less than" },
        .if_icmpge => .{ .name = "if_icmpge", .operand_count = 2, .description = "Branch if int greater than or equal" },
        .if_icmpgt => .{ .name = "if_icmpgt", .operand_count = 2, .description = "Branch if int greater than" },
        .if_icmple => .{ .name = "if_icmple", .operand_count = 2, .description = "Branch if int less than or equal" },
        .if_acmpeq => .{ .name = "if_acmpeq", .operand_count = 2, .description = "Branch if references equal" },
        .if_acmpne => .{ .name = "if_acmpne", .operand_count = 2, .description = "Branch if references not equal" },
        .goto => .{ .name = "goto", .operand_count = 2, .description = "Branch always" },
        .jsr => .{ .name = "jsr", .operand_count = 2, .description = "Jump subroutine" },
        .ret => .{ .name = "ret", .operand_count = 1, .description = "Return from subroutine" },
        .tableswitch => .{ .name = "tableswitch", .operand_count = 255, .description = "Access jump table by index" },
        .lookupswitch => .{ .name = "lookupswitch", .operand_count = 255, .description = "Access jump table by key match" },
        .ireturn => .{ .name = "ireturn", .operand_count = 0, .description = "Return int from method" },
        .lreturn => .{ .name = "lreturn", .operand_count = 0, .description = "Return long from method" },
        .freturn => .{ .name = "freturn", .operand_count = 0, .description = "Return float from method" },
        .dreturn => .{ .name = "dreturn", .operand_count = 0, .description = "Return double from method" },
        .areturn => .{ .name = "areturn", .operand_count = 0, .description = "Return reference from method" },
        .@"return" => .{ .name = "return", .operand_count = 0, .description = "Return void from method" },
        .getstatic => .{ .name = "getstatic", .operand_count = 2, .description = "Get static field" },
        .putstatic => .{ .name = "putstatic", .operand_count = 2, .description = "Put static field" },
        .getfield => .{ .name = "getfield", .operand_count = 2, .description = "Fetch field from object" },
        .putfield => .{ .name = "putfield", .operand_count = 2, .description = "Set field in object" },
        .invokevirtual => .{ .name = "invokevirtual", .operand_count = 2, .description = "Invoke instance method" },
        .invokespecial => .{ .name = "invokespecial", .operand_count = 2, .description = "Invoke instance method with special handling" },
        .invokestatic => .{ .name = "invokestatic", .operand_count = 2, .description = "Invoke static method" },
        .invokeinterface => .{ .name = "invokeinterface", .operand_count = 4, .description = "Invoke interface method" },
        .invokedynamic => .{ .name = "invokedynamic", .operand_count = 4, .description = "Invoke dynamic method" },
        .new => .{ .name = "new", .operand_count = 2, .description = "Create new object" },
        .newarray => .{ .name = "newarray", .operand_count = 1, .description = "Create new array" },
        .anewarray => .{ .name = "anewarray", .operand_count = 2, .description = "Create new array of reference" },
        .arraylength => .{ .name = "arraylength", .operand_count = 0, .description = "Get length of array" },
        .athrow => .{ .name = "athrow", .operand_count = 0, .description = "Throw exception" },
        .checkcast => .{ .name = "checkcast", .operand_count = 2, .description = "Check whether object is of given type" },
        .instanceof => .{ .name = "instanceof", .operand_count = 2, .description = "Determine if object is of given type" },
        .monitorenter => .{ .name = "monitorenter", .operand_count = 0, .description = "Enter monitor for object" },
        .monitorexit => .{ .name = "monitorexit", .operand_count = 0, .description = "Exit monitor for object" },
        .wide => .{ .name = "wide", .operand_count = 255, .description = "Extend local variable index by additional bytes" },
        .multianewarray => .{ .name = "multianewarray", .operand_count = 3, .description = "Create new multidimensional array" },
        .ifnull => .{ .name = "ifnull", .operand_count = 2, .description = "Branch if reference is null" },
        .ifnonnull => .{ .name = "ifnonnull", .operand_count = 2, .description = "Branch if reference not null" },
        .goto_w => .{ .name = "goto_w", .operand_count = 4, .description = "Branch always (wide index)" },
        .jsr_w => .{ .name = "jsr_w", .operand_count = 4, .description = "Jump subroutine (wide index)" },
        .breakpoint => .{ .name = "breakpoint", .operand_count = 0, .description = "Breakpoint" },
        .impdep1 => .{ .name = "impdep1", .operand_count = 0, .description = "Implementation dependent 1" },
        .impdep2 => .{ .name = "impdep2", .operand_count = 0, .description = "Implementation dependent 2" },
        _ => .{ .name = "unknown", .operand_count = 0, .description = "Unknown instruction" },
    };
}

pub fn opcodeFromByte(byte: u8) Opcode {
    return @enumFromInt(byte);
}

pub fn opcodeToString(opcode: Opcode) []const u8 {
    return getInstructionInfo(opcode).name;
}

pub fn opcodeOperandCount(opcode: Opcode) u8 {
    return getInstructionInfo(opcode).operand_count;
}
